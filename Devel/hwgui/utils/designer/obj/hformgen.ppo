#line 112 "d:\devel\xharbour_bcc7\include\hbclass.ch"
   DYNAMIC DivertConstructorCall
















DECLARE HBClass  New( cName AS String, OPTIONAL SuperParams ) AS CLASS HBClass  Create() AS Object  Instance() AS Object  AddClsMethod( cName AS String, @MethodName(), nScope AS Numeric, n2 AS Numeric, n3 AS Numeric )  AddDelegate( cName AS String, cDelegate AS String, cObject AS String, nScope AS Numeric, lPersistent AS LOGICAL )  AddMultiClsData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String )  AddMultiData( cType AS String, uVal, nScope AS Numeric, aDatas AS Array OF String, x AS LOGICAL, lPer AS LOGICAL )  AddMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  AddInLine( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  AddVirtual( cName AS String )  ModMethod( cName AS String, @MethodName(), nScope AS Numeric, lPersistent AS LOGICAL )  ModClsMethod( cName AS String, @MethodName(), nScope AS Numeric )  ModInline( cName AS String, bBlock AS CodeBlock, nScope AS Numeric, lPersistent AS LOGICAL )  SetOnError( @MethodName() )
#line 23 "source\hformgen.prg"
Static oPenDivider, oPenLine

Static aG := { "left","top","width","height","right","bottom" }







Static aStaticTypes := { { 0,"SS_LEFT" }, { 1,"SS_CENTER" },  { 2,"SS_RIGHT" }, { 7,"SS_BLACKFRAME" },             { 8,"SS_GRAYFRAME" }, { 9,"SS_WHITEFRAME" },     { 4,"SS_BLACKRECT" }, { 5,"SS_GRAYRECT" },         { 6,"SS_WHITERECT" }, { 18,"SS_ETCHEDFRAME" },   { 16,"SS_ETCHEDHORZ" }, { 17,"SS_ETCHEDVERT" },   { 13,"SS_OWNERDRAW" } }








Static aStyles := { { 2147483648,"WS_POPUP" }, { 1073741824,"WS_CHILD" }, { 268435456,"WS_VISIBLE" },  { 134217728,"WS_DISABLED" }, { 67108864,"WS_CLIPSIBLINGS" }, { 8388608,"WS_BORDER" },  { 4194304,"WS_DLGFRAME" }, { 2097152,"WS_VSCROLL" }, { 1048576,"WS_HSCROLL" },  { 524288,"WS_SYSMENU" }, { 262144,"WS_THICKFRAME" }, { 131072,"WS_GROUP" },  { 65536,"WS_TABSTOP" }, { 0,"BS_PUSHBUTTON" }, { 2,"BS_CHECKBOX" },  { 9,"BS_AUTORADIOBUTTON" }, { 128,"ES_AUTOHSCROLL" },  { 64,"ES_AUTOVSCROLL" }, { 4,"ES_MULTILINE" }, { 7,"BS_GROUPBOX" },  { 3,"CBS_DROPDOWNLIST" }, { 13,"SS_OWNERDRAW" }  }

_HB_CLASS HFormGen ; UTILITY FUNCTION HFormGen(...); static s_oClass ; local oClassInstance ; local nScope ; nScope := 1 ; ( nScope ) ; if s_oClass == NIL ; s_oClass := IIF(.F.,, HBClass():New( "HFormGen" , {HObject():classh} ) ) ; ;

   _HB_MEMBER { aForms} ; IIF( !.F., s_oClass:AddMultiClsData(, {}, nScope + IIF( .F., 32, 0 ) + IIF( .F., 64, 0 ), { "aForms" }, .F. ), )
   _HB_MEMBER { oDlgSelected} ; IIF( !.F., s_oClass:AddMultiClsData(,, nScope + IIF( .F., 32, 0 ) + IIF( .F., 64, 0 ), { "oDlgSelected" }, .F. ), )
   _HB_MEMBER { oParent} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oParent" }, .F., .F. ), )
   _HB_MEMBER { cEncoding} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "cEncoding" }, .F., .F. ), )
   _HB_MEMBER { oDlg} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oDlg" }, .F., .F. ), )
   _HB_MEMBER { name} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "name" }, .F., .F. ), )
   _HB_MEMBER { handle} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "handle" }, .F., .F. ), )
   _HB_MEMBER { filename, path} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "filename" , "path" }, .F., .F. ), )
   _HB_MEMBER { type} ; IIF( !.F., s_oClass:AddMultiData(, 1, nScope + IIF( .F., 32, 0 ), { "type" }, .F., .F. ), )
   _HB_MEMBER { lGet} ; IIF( !.F., s_oClass:AddMultiData(, .T., nScope + IIF( .F., 32, 0 ), { "lGet" }, .F., .F. ), )
   _HB_MEMBER { oCtrlSelected} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "oCtrlSelected" }, .F., .F. ), )
   _HB_MEMBER { lChanged} ; IIF( !.F., s_oClass:AddMultiData(, .F., nScope + IIF( .F., 32, 0 ), { "lChanged" }, .F., .F. ), )
   _HB_MEMBER { aProp} ; IIF( !.F., s_oClass:AddMultiData(, {}, nScope + IIF( .F., 32, 0 ), { "aProp" }, .F., .F. ), )
   _HB_MEMBER { aMethods} ; IIF( !.F., s_oClass:AddMultiData(, {}, nScope + IIF( .F., 32, 0 ), { "aMethods" }, .F., .F. ), )

   _HB_MEMBER { nPWidth, nPHeight, nKoeff} ; IIF( !.F., s_oClass:AddMultiData(,, nScope + IIF( .F., 32, 0 ), { "nPWidth" , "nPHeight" , "nKoeff" }, .F., .F. ), )
   _HB_MEMBER { nYOffset} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nYOffset" }, .F., .F. ), )
   _HB_MEMBER { nXOffset} ; IIF( !.F., s_oClass:AddMultiData(, 0, nScope + IIF( .F., 32, 0 ), { "nXOffset" }, .F., .F. ), )

   _HB_MEMBER New() AS CLASS HFormGen; IIF( .F., s_oClass:ModMethod( "New", @HFormGen_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "New", @HFormGen_New(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Open() AS CLASS HFormGen; IIF( .F., s_oClass:ModMethod( "Open", @HFormGen_Open(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Open", @HFormGen_Open(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER OpenR() AS CLASS HFormGen; IIF( .F., s_oClass:ModMethod( "OpenR", @HFormGen_OpenR(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "OpenR", @HFormGen_OpenR(), nScope + IIF( .T., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER Save( lAs); IIF( .F., s_oClass:ModMethod( "Save", @HFormGen_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "Save", @HFormGen_Save(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER CreateDialog( aProp); IIF( .F., s_oClass:ModMethod( "CreateDialog", @HFormGen_CreateDialog(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "CreateDialog", @HFormGen_CreateDialog(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER GetProp( cName); IIF( .F., s_oClass:ModMethod( "GetProp", @HFormGen_GetProp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "GetProp", @HFormGen_GetProp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetProp( xName,xValue); IIF( .F., s_oClass:ModMethod( "SetProp", @HFormGen_SetProp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetProp", @HFormGen_SetProp(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER SetPaper( cType,nOrientation); IIF( .F., s_oClass:ModMethod( "SetPaper", @HFormGen_SetPaper(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "SetPaper", @HFormGen_SetPaper(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));
   _HB_MEMBER End(); IIF( .F., s_oClass:ModMethod( "End", @HFormGen_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ), s_oClass:AddMethod( "End", @HFormGen_End(), nScope + IIF( .F., 16, 0 ) + IIF( .F., 1024, 0 ), .F. ));

; IF .F. ; __clsActive(s_oClass:hClass) ; s_oClass:Refresh() ; ELSE ; s_oClass:Create() ; END ; oClassInstance := __clsInst( s_oClass:hClass ) ; IF __ObjHasMsg( oClassInstance, "InitClass" ); oClassInstance:InitClass( hb_aParams() ) ; END ; ELSE ; oClassInstance := __clsInst( s_oClass:hClass ) ; END ; IF PCount() > 0 ; DIVERT TO (@DivertConstructorCall()) OF s_oClass ; END ; RETURN oClassInstance AS CLASS HFormGen ;

UTILITY STATIC function HFormGen_New() ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Local i := 1, name
Local hDCwindow := GetDC( GetActiveWindow() ), aTermMetr := GetDeviceArea( hDCwindow )

   DeleteDC( hDCwindow )
   while .T.
      name := "Form"+Ltrim(Str(i))
      IF Ascan( ::aForms,{|o|o:name==name} ) == 0
        Exit
      ENDIF
      i ++
   ENDDO

   ::type := 1
   ::name := name


   IF Getdesktopwidth() < 1024
     ::CreateDialog( { {"Left","225"}, {"Top","110"},{"Width","550"},{"Height","400"},{"Caption",name} } )
   ELSE
     ::CreateDialog( { {"Left","125"}, {"Top","150"},{"Width","750"},{"Height","600"},{"Caption",name} } )
   ENDIF
   ::filename := ""

   Aadd( ::aForms, Self )

   statusbarmsg(name)

Return Self

UTILITY STATIC function HFormGen_OpenR( fname) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Local oForm := ::aForms[1]
Memvar oDesigner
   IF !MsgYesNo( "The form will be opened INSTEAD of current ! Do you agree ?", "Designer")
      Return Nil
   ENDIF
   oDesigner:lSingleForm := .F.
   oForm:lChanged := .F.
   oForm:End()
   oDesigner:lSingleForm := .T.

Return ::Open( fname )

UTILITY STATIC function HFormGen_Open( fname,cForm) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Memvar oDesigner
Local aFormats := oDesigner:aFormats
Memvar oForm, aCtrlTable, cCurDir
Private oForm := Self, aCtrlTable

   IF fname <> Nil
      ::path := Filepath( fname )
      ::filename := CutPath( fname )
   ENDIF
   IF fname <> Nil .OR. cForm <> Nil .OR. FileDlg( Self,.T. )
      IF ::type == 1
         ReadForm( Self,cForm )
      ELSE
         IF Valtype( aFormats[ ::type,4 ] ) == "C"
            aFormats[ ::type,4 ] := OpenScript( cCurDir + aFormats[ ::type,3 ], aFormats[ ::type,4 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,6 ] ) == "C"
            aFormats[ ::type,6 ] := OpenScript( cCurDir + aFormats[ ::type,3 ], aFormats[ ::type,6 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,6 ] ) == "A"
            DoScript( aFormats[ ::type,6 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,4 ] ) == "A"
            DoScript( aFormats[ ::type,4 ] )
         ENDIF
      ENDIF
      IF ::oDlg <> Nil
         ::name := ::oDlg:title
         Aadd( ::aForms, Self )

             InspSetCombo()
      ENDIF
      IF ::oDlg == Nil .OR. Empty( ::oDlg:aControls )
         MsgStop( "Can't load the form", "Designer" )
      ELSEIF !oDesigner:lSingleForm .AND. fname <> Nil
         AddRecent( Self )
      ENDIF
   ENDIF

    statusbarmsg(fname)

RETURN Self

UTILITY STATIC function HFormGen_End( lDlg,lCloseDes) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Local i, j, name := ::name, oDlgSel
Memvar oDesigner

   IF lDlg == Nil; lDlg := .F.; ENDIF
   IF ::lChanged
      IF MsgYesNo( ::name + " was changed. Save it ?", "Designer" )
         ::Save()
      ENDIF
   ENDIF

   FOR i := 1 TO Len( HFormGen():aForms )
      IF HFormGen():aForms[i]:oDlg:handle <> ::oDlg:handle
         oDlgSel := HFormGen():aForms[i]:oDlg
      ELSE
         j := i
      ENDIF
   NEXT
   IF oDlgSel <> Nil
      SetDlgSelected( oDlgSel )
   ELSE
      HFormGen():oDlgSelected := Nil
      IF oDesigner:oDlgInsp <> Nil
         oDesigner:oDlgInsp:Close()

      ENDIF

      statusbarmsg("")

   ENDIF

   Adel( ::aForms,j )
   Asize( ::aForms, Len(::aForms)-1 )
   IF !lDlg
      ::oDlg:bDestroy := Nil
      EndDialog( ::oDlg:handle )
   ENDIF
   IF oDesigner:lSingleForm .AND. ( lCloseDes == Nil .OR. lCloseDes )
      oDesigner:oMainWnd:Close()
   ENDIF
RETURN .T.

UTILITY STATIC function HFormGen_Save( lAs) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Memvar oDesigner, cCurDir
Local aFormats := oDesigner:aFormats, aControls
Memvar oForm, aCtrlTable
Private oForm := Self, aCtrlTable

   IF lAs == Nil; lAs := .F.; ENDIF
   IF !::lChanged .AND. !lAs
      MsgStop( "Nothing to save", "Designer" )
      Return Nil
   ENDIF


   IF ( oDesigner:lSingleForm .AND. !lAs ) .OR.  ( ( Empty( ::filename ) .OR. lAs ) .AND. FileDlg( Self,.F. ) ) .OR. !Empty( ::filename )
      FrmSort( Self,Iif( oDesigner:lReport,::oDlg:aControls[1]:aControls[1]:aControls,::oDlg:aControls ) )
      IF ::type == 1
         aControls := WriteForm( Self )















      ELSE
         IF Valtype( aFormats[ ::type,5 ] ) == "C"
            aFormats[ ::type,5 ] := OpenScript( cCurDir + aFormats[ ::type,3 ], aFormats[ ::type,5 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,6 ] ) == "C"
            aFormats[ ::type,6 ] := OpenScript( cCurDir + aFormats[ ::type,3 ], aFormats[ ::type,6 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,6 ] ) == "A"
            DoScript( aFormats[ ::type,6 ] )
         ENDIF
         IF Valtype( aFormats[ ::type,5 ] ) == "A"
            DoScript( aFormats[ ::type,5 ] )
         ENDIF
      ENDIF
      IF !oDesigner:lSingleForm .AND. !( ::filename == "__tmp.xml" )
         AddRecent( Self )
      ENDIF
   ENDIF
   IF !lAs
      ::lChanged := .F.
   ENDIF

RETURN Nil

UTILITY STATIC function HFormGen_CreateDialog( aProp) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Memvar oDesigner
Local i, j, cPropertyName, xProperty, oFormDesc := oDesigner:oFormDesc
Local hDC, aMetr, oPanel
Memvar value, oCtrl
Private value, oCtrl






   ::oDlg := HDialog():New( Iif(.F.,10,11), 1+2147483648+268435456+12582912+524288+262144,,,,,,,,{|o|o:oParent:End(.T.)}, {|o,h,w|dlgOnSize(o,h,w)}, {|o|PaintDlg(o)},{|o|SetDlgSelected(o)},,,.F.,,,.F.,,,.F.,,, .F.,.F.)

   ::oDlg:oParent := Self
   ::handle := oDesigner:oMainWnd:handle

   oCtrl := ::oDlg
   IF oFormDesc <> Nil
      FOR i := 1 TO Len( oFormDesc:aItems )
         IF oFormDesc:aItems[i]:title == "property"
            IF !Empty( oFormDesc:aItems[i]:aItems )
               IF Valtype( oFormDesc:aItems[i]:aItems[1]:aItems[1] ) == "C"
                  oFormDesc:aItems[i]:aItems[1]:aItems[1] := &( "{||" + oFormDesc:aItems[i]:aItems[1]:aItems[1] + "}" )
               ENDIF
               xProperty := Eval( oFormDesc:aItems[i]:aItems[1]:aItems[1] )
            ELSE
               xProperty := oFormDesc:aItems[i]:GetAttribute( "value" )
            ENDIF


            Aadd( ::aProp, { oFormDesc:aItems[i]:GetAttribute( "name" ),   xProperty,  oFormDesc:aItems[i]:GetAttribute( "type" ) } )
            IF oFormDesc:aItems[i]:GetAttribute( "hidden" ) <> Nil
               Aadd( Atail( ::aProp ),.T. )
            ENDIF
         ELSEIF oFormDesc:aItems[i]:title == "method"
            Aadd( ::aMethods, { oFormDesc:aItems[i]:GetAttribute( "name" ),"" } )
         ENDIF
      NEXT
   ENDIF
   IF aProp <> Nil
      FOR i := 1 TO Len( aProp )
         cPropertyName := Lower( aProp[ i,1 ] )
         IF ( j := Ascan( ::aProp, {|a|Lower(a[1])==cPropertyName} ) ) <> 0
            IF !Empty( aProp[i,2] )
               ::aProp[j,2] := aProp[i,2]
            ENDIF
         ELSE

         ENDIF
      NEXT
   ENDIF
   FOR i := 1 TO Len( ::aProp )
      value := ::aProp[ i,2 ]
      IF value <> Nil
         cPropertyName := Lower( ::aProp[ i,1 ] )
         j := Ascan( oDesigner:aDataDef, {|a|a[1]==cPropertyName} )
         IF j <> 0 .AND. oDesigner:aDataDef[ j,3 ] <> Nil
            EvalCode( oDesigner:aDataDef[ j,3 ] )
         ENDIF
      ENDIF
   NEXT

   IF oDesigner:lReport
      hDC := GetDC( GetActiveWindow() )
      aMetr := GetDeviceArea( hDC )

      ::nKoeff := ( aMetr[1]/aMetr[3] + aMetr[2]/aMetr[4] ) / 2

      ReleaseDC( GetActiveWindow(),hDC )
      ::SetPaper( ::GetProp("Paper Size"),::GetProp("Orientation") )
      IF ::oDlg:oFont == Nil
         ::oDlg:oFont := HFont():Add( "Arial",0,-13 )
      ENDIF
      ::oDlg:style := Hwg_BitOr( ::oDlg:style,2097152+1048576+65536 )



      oPanel := HPanel():New(,,,40,30,Round(::nPWidth*::nKoeff,0)-1,Round(::nPHeight*::nKoeff,0)-1,,{||.T.},{|o|PaintPanel(o)}, ); oPanel:name := "oPanel"
      oPanel:brush := 0

      HPanel():New( oPanel,,,0,0,oPanel:nWidth,oPanel:nHeight,,{|o,x,y|o:Move(,,x,y)},{|o|PaintPanel(o)}, );
      oPanel:aControls[1]:brush := HBrush():Add( 16777215 )
      oPanel:aControls[1]:bOther := {|o,m,wp,lp|MessagesProc(o,m,wp,lp)}
      oPanel:bOther := {|o,m,wp,lp|Iif(m==257,MessagesProc(o,m,wp,lp),-1)}
      ::oDlg:bOther := {|o,m,wp,lp|ScrollProc(o,m,wp,lp)}
   ELSE
      ::oDlg:bOther := {|o,m,wp,lp|MessagesProc(o,m,wp,lp)}
   ENDIF

   ::oDlg:Activate(.T.)

   IF oDesigner:oDlgInsp == Nil

      InspOpen(IIF(Getdesktopwidth()>800,.T.,.F.))
      IF Getdesktopwidth()<=800
             oDesigner:oDlgInsp:HIDE()
          ENDIF

   ENDIF

RETURN Nil

UTILITY STATIC function HFormGen_GetProp( cName) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Local i
  cName := Lower( cName )
  i := Ascan( ::aProp,{|a|Lower(a[1])==cName} )
Return Iif( i==0, Nil, ::aProp[i,2] )

UTILITY STATIC function HFormGen_SetProp( xName,xValue) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen

   IF Valtype( xName ) == "C"
      xName := Lower( xName )
      xName := Ascan( ::aProp,{|a|Lower(a[1])==xName} )
   ENDIF
   IF xName <> 0
      ::aProp[xName,2] := xValue
   ENDIF
Return Nil

UTILITY STATIC function HFormGen_SetPaper( cType,cOrientation) ; local Self AS CLASS HFormGen := QSelf() AS CLASS HFormGen
Local ntemp, nx := ::nPWidth, ny := ::nPHeight

   IF Lower(cType) == "a4"
      ::nPWidth  := 210
      ::nPHeight := 297
   ELSEIF Lower(cType) == "a3"
      ::nPWidth  := 297
      ::nPHeight := 420
   ENDIF
   IF Lower(cOrientation) <> "portrait"
      ntemp :=   ::nPWidth
      ::nPWidth  := ::nPHeight
      ::nPHeight := ntemp
   ENDIF
   IF !Empty( ::oDlg:aControls ) .AND. ( nx <> ::nPWidth .OR. ny <> ::nPHeight )
      ::oDlg:aControls[1]:Move( ,,Round(::nPWidth*::nKoeff,0)-1,Round(::nPHeight*::nKoeff,0)-1 )
   ENDIF

Return Nil



Static Function dlgOnSize( oDlg,h,w )
Local aCoors := GetClientRect( oDlg:handle )
Memvar oDesigner


   IF !oDesigner:lReport

      IF  h=aCoors[3] .AND. w=aCoors[4]
         oDlg:oParent:SetProp("Width",Ltrim(Str(oDlg:nWidth:=aCoors[3])))
         oDlg:oParent:SetProp("Height",Ltrim(Str(oDlg:nHeight:=aCoors[4])))

     ELSE
       RedrawWindow( oDlg:handle, 4 + 1 )
       oDlg:show()
     ENDIF
      InspUpdBrowse()
      oDlg:oParent:lChanged:=.T.
   ENDIF
Return Nil

Static Function SetDlgSelected( oDlg )
Memvar oDesigner

   IF HFormGen():oDlgSelected == Nil .OR. HFormGen():oDlgSelected:handle <> oDlg:handle
      HFormGen():oDlgSelected := oDlg
      IF oDesigner:oDlgInsp <> Nil
         InspSetCombo()

        IF odlg:oParent:filename <> Nil
           statusbarmsg(IIF(odlg:oParent:path <> Nil,odlg:oParent:path,"") + oDlg:oParent:filename,"","")
         ENDIF

      ENDIF
   ENDIF
Return .T.

Function CnvCtrlName( cName,l2 )
Local i
Memvar aCtrlTable

   IF aCtrlTable == Nil
      Return cName
   ENDIF
   IF l2 == Nil
      l2 := .F.
   ENDIF
   IF l2
      i := Ascan( aCtrlTable,{|a|a[2]==cName} )
   ELSE
      i := Ascan( aCtrlTable,{|a|a[1]==cName} )
   ENDIF
Return Iif( i == 0, Nil, Iif( l2,aCtrlTable[i,1],aCtrlTable[i,2] ) )

Static Function FileDlg( oFrm,lOpen )
Memvar oDesigner
Local oDlg, aFormats := oDesigner:aFormats
Local aCombo := {}, af := {}, oEdit1, oEdit2
Local nType := 1, fname := Iif( lOpen.OR.oFrm:filename==Nil,"",oFrm:filename )
Local formname := Iif( lOpen,"",oFrm:name )
Local i

   FOR i := 1 TO Len( aFormats )

      IF i == 1 .OR. ( lOpen .AND. aFormats[ i,4 ] <> Nil ) .OR.  ( !lOpen .AND. aFormats[ i,5 ] <> Nil )
         Aadd( aCombo, aFormats[ i,1 ] )
         Aadd( af,i )
         IF !lOpen .AND. oFrm:type == i
            nType := Len( af )
         ENDIF
      ENDIF
   NEXT


   oDlg := HDialog():New( Iif(.F.,10,11),,50,100,310,250,Iif( lOpen,"Open form","Save form" ),oDesigner:oMainWnd:oFont,,,,,,,,.F.,,,.F.,,,.F.,,, .F.,.F.)


   HComboBox():New(,,nType, {|v|Iif(v==Nil,nType,nType:=v)},,10,20,140,24, aCombo,,,,,{||Iif(lOpen,.F.,(fname:=CutExten(fname)+Iif(!Empty(fname),"."+aFormats[af[nType],2],""),oEdit1:Refresh()))},, .F.,.F.,,,,,,,,,,.F.);



   oEdit1 := HEdit():New(,,fname, {|v|Iif(v==Nil,fname,fname:=v)}, 128,10,70,200,26,,,,,,,,,,, .F.,,.F.,,,,.F.,,.F.); oEdit1:name := "oEdit1"


   HButton():New(,,,210,70,80, 26,"Browse",,,,,{||BrowFile(lOpen,af[nType],oEdit1,oEdit2)},,,,,.F. );

   HStatic():New(,,,10,110,80, 22,"Form name:",,,,,,,,.F.,,,,.F. );

   oEdit2 := HEdit():New(,,formname, {|v|Iif(v==Nil,formname,formname:=v)},,10,135,140,26,,,,,,,,,,, .F.,,.F.,,,,.F.,,.F.); oEdit2:name := "oEdit2"

   HButton():New(,1,,20,200,100, 32,"Ok",,,,,,,,,,.F. );
   HButton():New(,2,,180,200,100, 32,"Cancel",,,,,,,,,,.F. );

   oDlg:Activate()

   IF oDlg:lResult
      oFrm:type := af[nType]
      oFrm:filename := CutPath( fname )
      IF Empty( FilExten( oFrm:filename ) )
         oFrm:filename += "."+aFormats[ af[nType],2 ]
      ENDIF
      oFrm:path := Iif( Empty( FilePath(fname) ), oDesigner:ds_mypath, FilePath(fname) )
      Return .T.
   ENDIF

Return .F.

Static Function BrowFile( lOpen,nType,oEdit1, oEdit2 )
Memvar oDesigner
Local fname, s1, s2, l_ds_mypath

   s2 := "*." + oDesigner:aFormats[ nType,2 ]
   s1 := oDesigner:aFormats[ nType,1 ] + "( " + s2 + " )"

   IF lOpen
      fname := SelectFile( {s1,"All files"}, {s2,"*.*"},oDesigner:ds_mypath )
   ELSE
      fname := SaveFile( s2,s1,s2,oDesigner:ds_mypath )
   ENDIF
   IF !Empty( fname )
      l_ds_mypath := Lower( FilePath( fname ) )
      IF !( oDesigner:ds_mypath == l_ds_mypath )
         oDesigner:ds_mypath := l_ds_mypath
         oDesigner:lChgPath  := .T.
      ENDIF
      fname := CutPath( fname )
      oEdit1:SetGet( fname )
      oEdit1:Refresh()
      SetFocus( oEdit2:handle )
   ENDIF

Return Nil

Static Function ReadTree( aParent,oDesc )
Local i, aTree := {}, oNode

   FOR i := 1 TO Len( oDesc:aItems )
      oNode := oDesc:aItems[i]
      IF oNode:type == 3
         aParent[4] := oNode:aItems[1]
      ELSE

         Aadd( aTree, { Nil, oNode:GetAttribute("name"),  Val( oNode:GetAttribute("id") ), Nil } )
         IF !Empty( oNode:aItems )
            aTree[ Len(aTree),1 ] := ReadTree( aTail( aTree ),oNode )
         ENDIF
      ENDIF
   NEXT

Return Iif( Empty(aTree), Nil, aTree )

Static Function ReadCtrls( oDlg, oCtrlDesc, oContainer, nPage )
Local i, j, o, aRect, aProp := {}, aItems := oCtrlDesc:aItems, oCtrl, cName, cProperty
Local cPropertyName
memvar oDesigner

   FOR i := 1 TO Len( aItems )
      IF aItems[i]:title == "style"
         FOR j := 1 TO Len( aItems[i]:aItems )
            o := aItems[i]:aItems[j]
            IF o:title == "property"
               cPropertyName := o:GetAttribute( "name" )
               IF Lower( cPropertyName ) == "geometry"
                  aRect := hfrm_Str2Arr( o:aItems[1] )
                  Aadd( aProp, { "Left", aRect[1] } )
                  Aadd( aProp, { "Top", aRect[2] } )
                  Aadd( aProp, { "Width", aRect[3] } )
                  Aadd( aProp, { "Height", aRect[4] } )
                  IF oDesigner:lReport
                     Aadd( aProp, { "Right", aRect[5] } )
                     Aadd( aProp, { "Bottom", aRect[6] } )
                  ENDIF
               ELSEIF Lower( cPropertyName ) == "font"
                  Aadd( aProp, { cPropertyName,hfrm_FontFromxml( o:aItems[1] ) } )
               ELSEIF Lower( cPropertyName ) == "atree"
                  Aadd( aProp, { cPropertyName,ReadTree( ,o ) } )
               ELSEIF !Empty(o:aItems)
                  cProperty := Left( o:aItems[1],1 )
                  IF cProperty == "["
                     cProperty := Substr( o:aItems[1],2,Len(o:aItems[1])-2 )
                  ELSEIF cProperty == "."
                     cProperty := Iif( Substr(o:aItems[1],2,1)=="T","True","False" )
                  ELSEIF cProperty == "{"
                     cProperty := hfrm_Str2Arr( o:aItems[1] )
                  ELSE
                     cProperty := o:aItems[1]
                  ENDIF
                  Aadd( aProp, { cPropertyName,cProperty } )
               ENDIF
            ENDIF
         NEXT
         IF Ascan( aProp,{|a|a[1]=="Name"} ) == 0
            Aadd( aProp, { "Name","" } )
         ENDIF
         oCtrl := HControlGen():New( oDlg, oCtrlDesc:GetAttribute( "class" ), aProp )
         IF oContainer <> Nil
            oContainer:AddControl( oCtrl )
            oCtrl:oContainer := oContainer
         ENDIF

         IF ( cProperty := oCtrlDesc:GetAttribute( "options" ) ) <> Nil .AND.  "embed" $ cProperty
            oCtrl:lEmbed := .T.
         ENDIF
         IF nPage <> Nil
            oCtrl:nPage := nPage
         ENDIF
      ELSEIF aItems[i]:title == "method"
         cName := aItems[i]:GetAttribute( "name" )
         IF ( j := Ascan( oCtrl:aMethods, {|a|a[1]==cName} ) ) <> 0
            oCtrl:aMethods[j,2] := aItems[i]:aItems[1]:aItems[1]
         ENDIF
      ELSEIF aItems[i]:title == "part"
         IF Lower( aItems[i]:GetAttribute( "class" ) ) == "pagesheet"
            FOR j := 1 TO Len( aItems[i]:aItems )
               ReadCtrls( oDlg,aItems[i]:aItems[j],oCtrl,Val(aItems[i]:GetAttribute( "page" )) )
            NEXT
         ELSE
            ReadCtrls( oDlg,aItems[i],oCtrl )
         ENDIF
         IF oCtrl <> Nil .AND. Lower( oCtrl:cClass ) == "page"
            aRect := oCtrl:GetProp( "Tabs" )
            IF aRect <> Nil .AND. !Empty( aRect )
               Page_Upd( oCtrl, aRect )
               Page_Select( oCtrl, 1, .T. )
            ENDIF
         ENDIF
      ENDIF
   NEXT

Return Nil

Static Function ReadForm( oForm,cForm )
Local oDoc := Iif( cForm<>Nil, HXMLDoc():ReadString(cForm), HXMLDoc():Read( oForm:path+oForm:filename ) )
Local i, j, aItems, o, aProp := {}, cPropertyName, aRect, cProperty
Memvar oDesigner

   IF Empty( oDoc:aItems )
      MsgStop( "Can't open "+oForm:path+oForm:filename, "Designer" )
      Return Nil
   ELSEIF oDoc:aItems[1]:title <> "part" .OR. oDoc:aItems[1]:GetAttribute( "class" ) <> Iif( oDesigner:lReport,"report","form" )
      MsgStop( "Form description isn't found", "Designer" )
      Return Nil
   ENDIF
   oForm:cEncoding := oDoc:GetAttribute( "encoding" )
   aItems := oDoc:aItems[1]:aItems
   FOR i := 1 TO Len( aItems )
      IF aItems[i]:title == "style"
         FOR j := 1 TO Len( aItems[i]:aItems )
            o := aItems[i]:aItems[j]
            IF o:title == "property"
               cPropertyName := o:GetAttribute( "name" )
               IF Lower( cPropertyName ) == "geometry"
                  aRect := hfrm_Str2Arr( o:aItems[1] )
                  Aadd( aProp, { "Left", aRect[1] } )
                  Aadd( aProp, { "Top", aRect[2] } )
                  Aadd( aProp, { "Width", aRect[3] } )
                  Aadd( aProp, { "Height", aRect[4] } )
               ELSEIF Lower( cPropertyName ) == "font"
                  Aadd( aProp, { cPropertyName,hfrm_FontFromxml( o:aItems[1] ) } )
               ELSEIF !Empty(o:aItems)
                  cProperty := Left( o:aItems[1],1 )
                  IF cProperty == "["
                     cProperty := Substr( o:aItems[1],2,Len(o:aItems[1])-2 )
                  ELSEIF cProperty == "."
                     cProperty := Iif( Substr(o:aItems[1],2,1)=="T","True","False" )
                  ELSEIF cProperty == "{"
                     cProperty := hfrm_Str2Arr( o:aItems[1] )
                  ELSE
                     cProperty := o:aItems[1]
                  ENDIF
                  Aadd( aProp, { cPropertyName,cProperty } )
               ENDIF
            ENDIF
         NEXT
         oForm:CreateDialog( aProp )
      ELSEIF aItems[i]:title == "method"
         cPropertyName := aItems[i]:GetAttribute( "name" )
         IF ( j := Ascan( oForm:aMethods, {|a|a[1]==cPropertyName} ) ) <> 0
            oForm:aMethods[j,2] := aItems[i]:aItems[1]:aItems[1]
         ENDIF
      ELSEIF aItems[i]:title == "part"
         ReadCtrls( Iif( oDesigner:lReport,oForm:oDlg:aControls[1]:aControls[1],oForm:oDlg ),aItems[i] )
      ENDIF
   NEXT
Return Nil

Function IsDefault( oCtrl,aPropItem )
Local j1, aItems := oCtrl:oXMLDesc:aItems, xProperty, cPropName := Lower(aPropItem[1])

   FOR j1 := 1 TO Len( aItems )

      IF aItems[j1]:title == "property" .AND.  Lower(aItems[j1]:GetAttribute("name")) == cPropName

         IF !Empty( aItems[j1]:aItems )
            IF Valtype( aItems[j1]:aItems[1]:aItems[1] ) == "C"
               aItems[j1]:aItems[1]:aItems[1] := &( "{||" + aItems[j1]:aItems[1]:aItems[1] + "}" )
            ENDIF
            xProperty := Eval( aItems[j1]:aItems[1]:aItems[1] )
         ELSE
            xProperty := aItems[j1]:GetAttribute( "value" )
         ENDIF

         IF xProperty <> Nil .AND. xProperty == aPropItem[2]
            Return .T.
         ENDIF
      ENDIF
   NEXT

Return .F.

Static Function WriteTree( aTree, oParent )
Local i, oNode, type

   FOR i := 1 TO Len( aTree )
      IF aTree[i,4] <> Nil .OR. ( Valtype( aTree[i,1] ) == "A" .AND. !Empty( aTree[i,1] ) )
         type := 0
      ELSE
         type := 1
      ENDIF

      oNode := oParent:Add( HXMLNode():New( "item", type,  { { "name",aTree[i,2] },{ "id",Ltrim(Str(aTree[i,3])) } } ) )
      IF aTree[i,4] <> Nil
         oNode:Add( HXMLNode():New( ,3,,aTree[i,4] ) )
      ENDIF
      IF Valtype( aTree[i,1] ) == "A" .AND. !Empty( aTree[i,1] )
         WriteTree( aTree[i,1], oNode )
      ENDIF
   NEXT
Return Nil

Static Function WriteCtrl( oParent,oCtrl,lRoot )
Local i, j, oNode, oNode1, oStyle, oMeth, aItems, cPropertyName, lDef
Local cProperty
Memvar oDesigner

   IF !lRoot .OR. oCtrl:oContainer == Nil
      aItems := oCtrl:oXMLDesc:aItems
      oNode := oParent:Add( HXMLNode():New( "part",,{ { "class",oCtrl:cClass } } ) )
      IF oCtrl:lEmbed
         oNode:SetAttribute( "options","embed" )
      ENDIF
      oStyle := oNode:Add( HXMLNode():New( "style" ) )
      IF oDesigner:lReport

         oStyle:Add( HXMLNode():New( "property",,{ { "name","Geometry" } },  hfrm_Arr2Str( { oCtrl:GetProp("Left"),oCtrl:GetProp("Top"),oCtrl:GetProp("Width"),oCtrl:GetProp("Height"),oCtrl:GetProp("Right"),oCtrl:GetProp("Bottom") } ) ) )
      ELSE

         oStyle:Add( HXMLNode():New( "property",,{ { "name","Geometry" } },  hfrm_Arr2Str( { oCtrl:GetProp("Left"),oCtrl:GetProp("Top"),oCtrl:GetProp("Width"),oCtrl:GetProp("Height") } ) ) )
      ENDIF
      FOR j := 1 TO Len( oCtrl:aProp )
         cPropertyName := Lower(oCtrl:aProp[j,1])
         IF Ascan( aG,cPropertyName  ) <> 0
            lDef := .T.





         ELSEIF ( cPropertyName == "name" .AND. Empty( oCtrl:aProp[j,2] ) )
            lDef := .T.
         ELSE
            lDef := IsDefault( oCtrl, oCtrl:aProp[j] )
         ENDIF
         IF !lDef
            IF Lower(oCtrl:aProp[j,1]) == "font"
               IF oCtrl:oFont <> Nil
                  oNode1 := oStyle:Add( HXMLNode():New( "property",,{ { "name","font" } } ) )
                  oNode1:Add( Font2XML( oCtrl:oFont ) )
               ENDIF
            ELSEIF Lower(oCtrl:aProp[j,1]) == "atree"
               oNode1 := oStyle:Add( HXMLNode():New( "property",,{ { "name","atree" } } ) )
               WriteTree( oCtrl:aProp[j,2],oNode1 )
            ELSEIF oCtrl:aProp[j,2] <> Nil
               IF oCtrl:aProp[j,3] == "C"
                  cProperty := "[" + oCtrl:aProp[j,2] + "]"
               ELSEIF oCtrl:aProp[j,3] == "N"
                  cProperty := oCtrl:aProp[j,2]
               ELSEIF oCtrl:aProp[j,3] == "L"
                  cProperty := Iif( Lower( oCtrl:aProp[j,2] ) == "true",".T.",".F." )
               ELSEIF oCtrl:aProp[j,3] == "A"
                  cProperty := hfrm_Arr2Str( oCtrl:aProp[j,2] )
               ELSE
                  cProperty := ""
               ENDIF
               oStyle:Add( HXMLNode():New( "property",,{ { "name",oCtrl:aProp[j,1] } },cProperty ) )
            ENDIF
         ENDIF
      NEXT
      FOR j := 1 TO Len( oCtrl:aMethods )
         IF !Empty( oCtrl:aMethods[j,2] )
            oMeth := oNode:Add( HXMLNode():New( "method",,{ { "name",oCtrl:aMethods[j,1] } } ) )
            oMeth:Add( HXMLNode():New( ,3,,oCtrl:aMethods[j,2] ) )
         ENDIF
      NEXT
      IF !Empty( oCtrl:aControls )


         IF Lower( oCtrl:cClass ) == "page" .AND.  ( aItems := oCtrl:GetProp("Tabs") ) <> Nil .AND.  !Empty( aItems )
            FOR j := 1 TO Len( aItems )
               oNode1 := oNode:Add( HXMLNode():New( "part",,{ { "class","PageSheet" },{ "page",Ltrim(Str(j)) } } ) )
               FOR i := 1 TO Len( oCtrl:aControls )
                  IF oCtrl:aControls[i]:nPage == j
                     WriteCtrl( oNode1,oCtrl:aControls[i],.F. )
                  ENDIF
               NEXT
            NEXT
         ELSE
            FOR i := 1 TO Len( oCtrl:aControls )
               WriteCtrl( oNode,oCtrl:aControls[i],.F. )
            NEXT
         ENDIF
      ENDIF
   ENDIF

Return Nil

Static Function WriteForm( oForm )
Local oDoc := HXMLDoc():New( oForm:cEncoding )
Local oNode, oNode1, oStyle, i, oMeth, cProperty, aControls
Memvar oDesigner

   oNode := oDoc:Add( HXMLNode():New( "part",,{ { "class",Iif(oDesigner:lReport,"report","form") } } ) )
   oStyle := oNode:Add( HXMLNode():New( "style" ) )

   oStyle:Add( HXMLNode():New( "property",,{ { "name","Geometry" } },  hfrm_Arr2Str( { oForm:oDlg:nLeft,oForm:oDlg:nTop,oForm:oDlg:nWidth,oForm:oDlg:nHeight } ) ) )
   FOR i := 1 TO Len( oForm:aProp )
      IF Ascan( aG, Lower(oForm:aProp[i,1]) ) == 0
         IF Lower(oForm:aProp[i,1]) == "font"
            IF oForm:oDlg:oFont <> Nil
               oNode1 := oStyle:Add( HXMLNode():New( "property",,{ { "name",oForm:aProp[i,1] } } ) )
               oNode1:Add( Font2XML( oForm:oDlg:oFont ) )
            ENDIF
         ELSEIF oForm:aProp[i,2] <> Nil
            IF oForm:aProp[i,3] == "C"
               cProperty := "[" + oForm:aProp[i,2] + "]"
            ELSEIF oForm:aProp[i,3] == "N"
               cProperty := oForm:aProp[i,2]
            ELSEIF oForm:aProp[i,3] == "L"
               cProperty := Iif( Lower( oForm:aProp[i,2] ) == "true",".T.",".F." )
            ELSEIF oForm:aProp[i,3] == "A"
               cProperty := hfrm_Arr2Str( oForm:aProp[i,2] )
            ELSE
               cProperty := ""
            ENDIF
            oStyle:Add( HXMLNode():New( "property",,{ { "name",oForm:aProp[i,1] } },cProperty ) )
         ENDIF
      ENDIF
   NEXT
   FOR i := 1 TO Len( oForm:aMethods )
      IF !Empty( oForm:aMethods[i,2] )
         oMeth := oNode:Add( HXMLNode():New( "method",,{ { "name",oForm:aMethods[i,1] } } ) )
         oMeth:Add( HXMLNode():New( ,3,,oForm:aMethods[i,2] ) )
      ENDIF
   NEXT
   aControls := Iif( oDesigner:lReport,oForm:oDlg:aControls[1]:aControls[1]:aControls,oForm:oDlg:aControls )
   FOR i := 1 TO Len( aControls )
      WriteCtrl( oNode,aControls[i],.T. )
   NEXT

   IF oDesigner:lSingleForm
      oDesigner:cResForm := oDoc:Save()
   ELSE
      oDoc:Save( oForm:path + oForm:filename )
   ENDIF
Return Nil

static Function PaintDlg( oDlg )
Local pps, hDC, aCoors, oCtrl := GetCtrlSelected( oDlg ), oForm := oDlg:oParent
Local x1 := 40, y1 := 30, i, n1cm, xt, yt
Local oldBkColor, nTop, nLeft, nRight, nBottom
Memvar oDesigner

   pps := DefinePaintStru()
   hDC := BeginPaint( oDlg:handle, pps )



   IF oDesigner:lReport
      aCoors := GetClientRect( oDlg:handle )


      n1cm := Round( oForm:nKoeff * 10, 0 )

      FillRect( hDC, 0, 0, aCoors[3], 30-5, 22+1 )
      FillRect( hDC, 0, 0, 40-12, aCoors[4], 22+1 )
      i := 0

      SelectObject( hDC,oDlg:oFont:handle )
      oldBkColor := SetBkColor( hDC,GetSysColor(22) )
      while i*n1cm < (aCoors[3]-aCoors[1]-40)
         xt := x1+i*n1cm
         DrawLine( hDC,xt+Round(n1cm/4,0),0,xt+Round(n1cm/4,0),4 )
         DrawLine( hDC,xt+Round(n1cm/2,0),0,xt+Round(n1cm/2,0),8 )
         DrawLine( hDC,xt+Round(n1cm*3/4,0),0,xt+Round(n1cm*3/4,0),4 )
         DrawLine( hDC,xt,0,xt,12 )
         IF i > 0
            DrawText( hDC,Ltrim(Str(i+oForm:nXOffset/10,2)),xt-15,12,xt+15,30-5,1 )
         ENDIF
         i++
      ENDDO
      i := 0
      while i*n1cm < (aCoors[4]-aCoors[2]-30)
         yt := y1+i*n1cm
         DrawLine( hDC,0,yt+Round(n1cm/4,0),4,yt+Round(n1cm/4,0) )
         DrawLine( hDC,0,yt+Round(n1cm/2,0),8,yt+Round(n1cm/2,0) )
         DrawLine( hDC,0,yt+Round(n1cm*3/4,0),4,yt+Round(n1cm*3/4,0) )
         DrawLine( hDC,0,yt,12,yt )
         IF i > 0
            DrawText( hDC,Ltrim(Str(i+oForm:nYOffset/10,2)),12,yt-10,40-12,yt+10,1 )
         ENDIF
         i++
      ENDDO

      SetScrollInfo( oDlg:handle, 0, 1, oForm:nXOffset/10+1, 1, Round((oForm:nPWidth-(aCoors[3]-40)/oForm:nKoeff)/10,0)+1 )
      SetScrollInfo( oDlg:handle, 1, 1, oForm:nYOffset/10+1, 1, Round((oForm:nPHeight-(aCoors[4]-30)/oForm:nKoeff)/10,0)+1 )
   ELSE

      if oDesigner:lShowGrid
          aCoors := GetClientRect( oDlg:handle )
          nTop   := aCoors[1]
          nLeft  := aCoors[2]
          nRight := aCoors[3]
          nBottom := aCoors[4]           *  2

          SetROP2(hDC,9)
          oPenDivider := HPen():Add( 2 ,1,VColor("606060") )
          SelectObject( hDC,oPenDivider:handle )

          for i := nLeft+oDesigner:nPixelGrid to nRight step oDesigner:nPixelGrid
              DrawLine( hDC, i, nTop,i, nBottom )
          next
          for i := nTop+oDesigner:nPixelGrid to nBottom step oDesigner:nPixelGrid
             DrawLine( hDC, nLeft+2, i, nRight, i )
          next

          SetROP2(hDC,13)
          oPenDivider := HPen():Add( 0 ,1,VColor("0") )
          SelectObject( hDC,oPenDivider:handle )

      endif

      IF oCtrl <> Nil .AND. oCtrl:nTop >= 0




         Rectangle( hDC, oCtrl:nLeft-1, oCtrl:nTop-1,  oCtrl:nLeft+oCtrl:nWidth, oCtrl:nTop+oCtrl:nHeight )

      ENDIF

















   ENDIF

   EndPaint( oDlg:handle, pps )

Return Nil

Static Function PaintPanel( oPanel )
Local pps, hDC

   pps := DefinePaintStru()
   hDC := BeginPaint( oPanel:handle, pps )

   IF oPanel:oParent:Classname() == "HPANEL"
   ENDIF

   EndPaint( oPanel:handle, pps )

Return Nil

Static Function MessagesProc( oDlg, msg, wParam, lParam )
LOCAL oCtrl, aCoors, nShift, nKshift, asels,i
Memvar oDesigner


   IF msg == 512
      MouseMove( oDlg, wParam, LoWord( lParam ), HiWord( lParam ) )
      Return 1
   ELSEIF msg == 513
      StatusBarMsg(,"","")
      LButtonDown( oDlg, LoWord( lParam ), HiWord( lParam ) )
      Return 1
   ELSEIF msg == 514
      LButtonUp( oDlg, LoWord( lParam ), HiWord( lParam ) )
      Return 1
   ELSEIF msg == 517
      RButtonUp( oDlg, LoWord( lParam ), HiWord( lParam ) )
      Return 1
   ELSEIF msg == 515
         nkShift := GetKeyState(0x12)
         IF nkShift < 0  .OR. GetCtrlSelected( Iif(oDlg:oParent:Classname()=="HDIALOG",oDlg:oParent,oDlg) )<> Nil
             Iif( oDesigner:oDlgInsp==Nil,InspOpen(),InspShow())
          ELSE
            socontroles()
         ENDIF
      Return 1
   ELSEIF msg == 3
      IF !oDesigner:lReport
         aCoors := GetWindowRect( oDlg:handle )
         oDlg:oParent:SetProp( "Left", Ltrim(Str(oDlg:nLeft := aCoors[1])) )
         oDlg:oParent:SetProp( "Top", Ltrim(Str(oDlg:nTop  := aCoors[2])) )
         InspUpdBrowse()
         oDlg:oParent:lChanged := .T.
      ENDIF
   ELSEIF msg == 256
      IF wParam == 46
         DeleteCtrl()
      ENDIF
      IF wParam == 34 .OR. wParam == 33
        oCtrl := GetCtrlSelected( Iif(oDlg:oParent:Classname()=="HDIALOG",oDlg:oParent,oDlg) )
        IF oCtrl <> Nil
           asels := aselCtrls()
              FOR i = 1 to IIF(len(asels) > 0,LEN(asels),1)
                 oCtrl:=asels[i]
               SetBDown( ,0,0,0 )
               CtrlMove( oCtrl,0,IIF(wParam == 34,1,-1),.F. )
             NEXT
           return 1
        ENDIF
         ENDIF
      IF wParam == 35 .OR. wParam == 36
        oCtrl := GetCtrlSelected( Iif(oDlg:oParent:Classname()=="HDIALOG",oDlg:oParent,oDlg) )
        IF oCtrl <> Nil
           asels := aselCtrls()
              FOR i = 1 to IIF(len(asels) > 0,LEN(asels),1)
                 oCtrl:=asels[i]
               SetBDown( ,0,0,0 )
               CtrlMove( oCtrl,IIF(wParam == 35,1,-1),0,.F. )
             NEXT
            return 1
        ENDIF
         ENDIF

   ELSEIF msg == 257
      nkShift := GetKeyState(0x10)
      nShift := Iif( GetKeyState(17)<0,10,1 )
      oCtrl := GetCtrlSelected( Iif(oDlg:oParent:Classname()=="HDIALOG",oDlg:oParent,oDlg) )
      IF wParam == 40
         IF oCtrl <> Nil
           IF nKshift >= 0
                  SetBDown( ,0,0,0 )
                 CtrlMove( oCtrl,0,nShift,.F. )
                 return 1
           ELSE
               SetBDown( , oCtrl:nLeft,oCtrl:nTop,4 )
             CtrlResize( OCTRL,oCtrl:nLeft,oCtrl:nTop+1)
             return 1
           ENDIF
         ENDIF
      ELSEIF wParam == 38
         IF oCtrl <> Nil
           IF nKshift >= 0
                 SetBDown( ,0,0,0 )
                CtrlMove( oCtrl,0,-nShift,.F. )
                 return 1
           ELSE
               SetBDown( , oCtrl:nLeft,oCtrl:nTop,4 )
             CtrlResize( OCTRL,oCtrl:nLeft,oCtrl:nTop-1)
             return 1
           ENDIF
         ENDIF
      ELSEIF wParam == 39
         IF oCtrl <> Nil
             IF nKshift >= 0
             SetBDown( ,0,0,0 )
             CtrlMove( oCtrl,nShift,0,.F. )
           ELSE
               SetBDown( , oCtrl:nLeft,oCtrl:nTop,3 )
             CtrlResize( OCTRL,oCtrl:nLeft+1,oCtrl:nTop)
             return 1
           ENDIF
         ENDIF
      ELSEIF wParam == 37
         IF oCtrl <> Nil
           IF nKshift >= 0
             SetBDown( ,0,0,0 )
             CtrlMove( oCtrl,-nShift,0,.F. )
           ELSE
               SetBDown( , oCtrl:nLeft,oCtrl:nTop,3 )
             CtrlResize( OCTRL,oCtrl:nLeft-1,oCtrl:nTop)
             return 1
           ENDIF
           ENDIF
      ENDIF

      IF oCtrl <> Nil

         statusbarmsg(,"x: "+ltrim(str(oCtrl:nLeft))+"  y: "+ltrim(str(oCtrl:nTop)), "w: "+ltrim(str(oCtrl:nWidth))+"  h: "+ltrim(str(oCtrl:nHeight)))
      ELSE
         statusbarmsg(,"","")
         ENDIF

   ENDIF

Return -1

Static Function ScrollProc( oDlg, msg, wParam, lParam )
Local nScrollCode := LoWord( wParam ), nNewPos := HiWord( wParam )
Local oPanel := oDlg:aControls[1]:aControls[1]
Local aCoors, nSize, x

   ( (lParam) := (lParam) )


   IF msg == 277
      x := oDlg:oParent:nYOffset
      aCoors := GetClientRect( oDlg:handle )
      nSize  := ( aCoors[4] - 30 ) / oDlg:oParent:nKoeff
      IF nScrollCode == 1
         IF oDlg:oParent:nYOffset + nSize < oDlg:oParent:nPHeight
            oDlg:oParent:nYOffset += 10
         ENDIF
      ELSEIF nScrollCode == 0
         IF oDlg:oParent:nYOffset > 0
            oDlg:oParent:nYOffset -= 10
         ENDIF
      ELSEIF nScrollCode == 5
         IF --nNewPos <> oDlg:oParent:nYOffset/10
            oDlg:oParent:nYOffset := nNewPos * 10
         ENDIF
      ENDIF
      IF x <> oDlg:oParent:nYOffset
         oPanel:Move( , - Round(oDlg:oParent:nYOffset*oDlg:oParent:nKoeff,0 ) )
         IF oDlg:oParent:nYOffset + nSize >= oDlg:oParent:nPHeight
            RedrawWindow( oDlg:handle, 4 + 1 )
         ELSE
            InvalidateRect( oDlg:handle, 0, 0, 30, aCoors[3], aCoors[4] )
            SendMessage( oDlg:handle, 15, 0, 0 )
         ENDIF
      ENDIF

   ELSEIF msg == 276
      x := oDlg:oParent:nXOffset
      aCoors := GetClientRect( oDlg:handle )
      nSize  := ( aCoors[3] - 40 ) / oDlg:oParent:nKoeff
      IF nScrollCode == 1
         IF oDlg:oParent:nXOffset + nSize < oDlg:oParent:nPWidth
            oDlg:oParent:nXOffset += 10
         ENDIF
      ELSEIF nScrollCode == 0
         IF oDlg:oParent:nXOffset > 0
            oDlg:oParent:nXOffset -= 10
         ENDIF
      ELSEIF nScrollCode == 5
         IF --nNewPos <> oDlg:oParent:nXOffset/10
            oDlg:oParent:nXOffset := nNewPos * 10
         ENDIF
      ENDIF
      IF x <> oDlg:oParent:nXOffset
         oPanel:Move( - Round(oDlg:oParent:nXOffset*oDlg:oParent:nKoeff,0 ) )
         IF oDlg:oParent:nXOffset + nSize >= oDlg:oParent:nPWidth
            RedrawWindow( oDlg:handle, 4 + 1 )
         ELSE
            InvalidateRect( oDlg:handle, 0, 40, 0, aCoors[3], aCoors[4] )
            SendMessage( oDlg:handle, 15, 0, 0 )
         ENDIF
      ENDIF




   ENDIF

Return -1


Static Function MouseMove( oDlg, wParam, xPos, yPos )
Local aBDown, oCtrl, resizeDirection
Memvar oDesigner, crossCursor, horzCursor, VertCursor, handCursor

   ( (wParam) := (wParam) )

   IF oDesigner:addItem <> Nil
      Hwg_SetCursor( crossCursor )
   ELSE

       aBDown := GetBDown()

      IF aBDown[1]:CLASSNAME()="HDIALOG" .OR. aBDown[1]:CLASSNAME()="HPANEL"
        Hwg_SetCursor( handCursor )
        RegionSelect(odlg,aBDown[ 2 ],aBDown[ 3 ],xpos,ypos)
        RETURN Nil
      ENDIF

      IF aBDown[1] <> Nil
         IF aBDown[4] > 0
            IF aBDown[4] == 1 .OR. aBDown[4] == 3
               Hwg_SetCursor( horzCursor )
            ELSEIF aBDown[4] == 2 .OR. aBDown[4] == 4
               Hwg_SetCursor( vertCursor )
            ENDIF
            CtrlResize( aBDown[1],xPos,yPos )
         ELSE
            CtrlMove( aBDown[1],xPos,yPos,.T. )
         ENDIF
      ELSE
         IF ( oCtrl := GetCtrlSelected( oDlg ) ) <> Nil
            IF ( resizeDirection := CheckResize( oCtrl,xPos,yPos ) ) == 1 .OR. resizeDirection == 3
               Hwg_SetCursor( horzCursor )
            ELSEIF resizeDirection == 2 .OR. resizeDirection == 4
               Hwg_SetCursor( vertCursor )
            ENDIF
            SetvBDown( nil,xPos - oCtrl:nLeft , yPos - oCtrl:nTop,0 )
         ENDIF
      ENDIF
   ENDIF

Return Nil

Static Function LButtonDown( oDlg, xPos, yPos )
Local oCtrl := GetCtrlSelected( oDlg ), resizeDirection, flag, i
Memvar oDesigner, crossCursor, horzCursor, VertCursor, handCursor


      IF oCtrl = Nil.AND.oDesigner:addItem = Nil
         Hwg_SetCursor( handCursor )
         SetBDown(oDlg ,xPos,yPos)

      ENDIF


   IF oDesigner:addItem <> Nil
      Return Nil
   ENDIF


   IF oCtrl <> Nil .AND.  ( resizeDirection := CheckResize( oCtrl,xPos,yPos ) ) > 0
      IF resizeDirection == 1 .OR. resizeDirection == 3
         i := Ascan( oCtrl:aProp,{|a|Lower(a[1])=="height"} )
         IF i <> 0 .AND. ( Len( oCtrl:aProp[i] ) == 3 .OR. oDesigner:lReport )
            SetBDown( oCtrl,xPos,yPos,resizeDirection )
            Hwg_SetCursor( horzCursor )
         ENDIF
      ELSEIF resizeDirection == 2 .OR. resizeDirection == 4
         i := Ascan( oCtrl:aProp,{|a|Lower(a[1])=="width"} )
         IF i <> 0 .AND. ( Len( oCtrl:aProp[i] ) == 3 .OR. oDesigner:lReport )
            SetBDown( oCtrl,xPos,yPos,resizeDirection )
            Hwg_SetCursor( vertCursor )
         ENDIF
      ENDIF
   ELSE
      IF ( oCtrl := CtrlByPos( oDlg,xPos,yPos ) ) <> Nil
         IF oCtrl:Adjust == 0
            SetBDown( oCtrl,xPos,yPos,0 )
         ELSE
            SetCtrlSelected( oCtrl:oParent,oCtrl)
             ENDIF
      ELSEIF ( oCtrl := GetCtrlSelected( oDlg ) ) <> Nil

         SetCtrlSelected( oDlg )
         Hwg_SetCursor( handCursor )

      ENDIF
   ENDIF
   IF oCtrl <> Nil .AND. Lower( oCtrl:cClass ) == "page"
      i := Tab_HitTest( oCtrl:handle,,,@flag )
      IF i >= 0 .AND. flag == 4 .OR. flag == 6
         Page_Select( oCtrl, i+1 )
      ENDIF
   ENDIF

   IF oCtrl <> Nil

     statusbarmsg(,"x: "+ltrim(str(oCtrl:nLeft))+"  y: "+ltrim(str(oCtrl:nTop)), "w: "+ltrim(str(oCtrl:nWidth))+"  h: "+ltrim(str(oCtrl:nHeight)))
   ENDIF


Return Nil

Static Function LButtonUp( oDlg, xPos, yPos ,nShift)
Local aBDown, oCtrl, oContainer, i, aProp, j, name
Memvar oDesigner

   ( (nShift) := (nShift) )

   IF oDesigner:addItem == Nil
      aBDown := GetBDown()
      oCtrl := aBDown[1]

      IF oCtrl:CLASSNAME() = "HDIALOG" .OR. oCtrl:CLASSNAME() = "HPANEL"
        selsobjetos(odlg,aBDown[ 2 ],aBDown[ 3 ],xpos,ypos)

        InvalidateRect( odlg:handle, 1,  0, 0,  oDlg:nWidth,oDlg:nHeight )
        SetBDown( Nil,0,0,0 )
         return -1
      endif

      IF oCtrl <> Nil
         IF aBDown[4] > 0
            CtrlResize( oCtrl,xPos,yPos )
         ELSE

            CtrlMove( oCtrl,xPos,yPos,.T. )
            Container( oDlg,oCtrl )
         ENDIF
         SetBDown( Nil,0,0,0 )
      ENDIF
   ELSE
      oContainer := CtrlByPos( oDlg,xPos,yPos )
      IF oDesigner:addItem:classname() == "HCONTROLGEN"
         aProp := AClone( oDesigner:addItem:aProp )
         j := 0
         FOR i := Len( aProp ) TO 1 STEP -1
            IF ( name := Lower( aProp[i,1] ) ) == "name" .OR. name == "varname"
               Adel( aProp,i )
               j ++
            ELSEIF name == "left"
               aProp[i,2] := Ltrim(Str(Iif(oDesigner:lReport,Round(xPos/oDlg:oParent:oParent:oParent:nKoeff,1),xPos)))
            ELSEIF name == "top"
               aProp[i,2] := Ltrim(Str(Iif(oDesigner:lReport,Round(yPos/oDlg:oParent:oParent:oParent:nKoeff,1),yPos)))
            ENDIF
            IF oDesigner:lReport
               IF name == "right" .OR. name == "bottom"
                  aProp[i,2] := "0"
               ENDIF
            ENDIF
         NEXT
         IF j > 0
            Asize( aProp,Len(aProp)-j )
         ENDIF
         oCtrl := HControlGen():New( oDlg,oDesigner:addItem:oXMLDesc, aProp )
         IF oDesigner:lReport
            oCtrl:SetCoor( "Right",oCtrl:nLeft+oCtrl:nWidth-1 )
            oCtrl:SetCoor( "Bottom",oCtrl:nTop+oCtrl:nHeight-1 )
         ENDIF
      ELSE
         IF oDesigner:lReport


            oCtrl := HControlGen():New( oDlg,oDesigner:addItem, {  { "Left",Ltrim(Str(Round(xPos/oDlg:oParent:oParent:oParent:nKoeff,1))) },  { "Top",Ltrim(Str(Round(yPos/oDlg:oParent:oParent:oParent:nKoeff,1))) } } )
            oCtrl:SetCoor( "Right",oCtrl:nLeft+oCtrl:nWidth-1 )
            oCtrl:SetCoor( "Bottom",oCtrl:nTop+oCtrl:nHeight-1 )
         ELSE


            oCtrl := HControlGen():New( oDlg,oDesigner:addItem, {  { "Left",Ltrim(Str(xPos)) },  { "Top",Ltrim(Str(yPos)) } } )
         ENDIF
      ENDIF


      IF oContainer <> Nil .AND. (  oCtrl:nLeft+oCtrl:nWidth <= oContainer:nLeft+oContainer:nWidth .AND.  oCtrl:nTop+oCtrl:nHeight <= oContainer:nTop+oContainer:nHeight )
         oContainer:AddControl( oCtrl )
         oCtrl:oContainer := oContainer
         IF Lower( oContainer:cClass ) == "page"
            oCtrl:nPage := GetCurrentTab( oContainer:handle )
            IF oCtrl:nPage == 0
               oCtrl:nPage ++
            ENDIF
         ENDIF
      ENDIF

      SetCtrlSelected( oDlg,oCtrl)
      IF oDesigner:lReport
         oDlg:oParent:oParent:oParent:lChanged := .T.
      ELSE
         oDlg:oParent:lChanged := .T.
      ENDIF
      IF oDesigner:oBtnPressed <> Nil
         oDesigner:oBtnPressed:Release()
      ENDIF
      oDesigner:addItem := Nil
      IF IsCheckedMenuItem( oDesigner:oMainWnd:handle,1011 )
         AdjustCtrl( oCtrl )
      ENDIF
   ENDIF

Return -1

Static Function RButtonUp( oDlg, xPos, yPos )
Local oCtrl
Memvar oDesigner

   IF oDesigner:addItem == Nil
      IF ( oCtrl := CtrlByPos( oDlg,xPos,yPos ) ) <> Nil
         SetCtrlSelected( oDlg,oCtrl )
         IF Lower( oCtrl:cClass ) == "page"
            oDesigner:oTabMenu:Show( oDlg,xPos,yPos,.T. )
         ELSE

            IF oDesigner:lReport .AND. Lower( oCtrl:cClass ) $ "hline.vline"  .AND. oCtrl:oContainer <> Nil .AND. Lower( oCtrl:oContainer:cClass ) == "box"
               EnableMenuItem( oDesigner:oCtrlMenu,1030,.T. )
               IF oCtrl:lEmbed
                  CheckMenuItem( oDesigner:oCtrlMenu,1030,.T. )
               ELSE
                  CheckMenuItem( oDesigner:oCtrlMenu,1030,.F. )
               ENDIF
            ELSE
               EnableMenuItem( oDesigner:oCtrlMenu,1030,.F. )
            ENDIF
            oDesigner:oCtrlMenu:Show( Iif(oDesigner:lReport,oDlg:oParent:oParent,oDlg),xPos,yPos,.T. )
         ENDIF
      ELSE
         oDesigner:oDlgMenu:Show( Iif(oDesigner:lReport,oDlg:oParent:oParent,oDlg),xPos,yPos,.T. )
      ENDIF
   ENDIF

Return Nil

Function Container( oDlg,oCtrl )
Local i, nLeft := oCtrl:nLeft
Local oContainer

   oCtrl:nLeft := 9999
   oContainer := CtrlByRect( oDlg,nLeft,oCtrl:nTop,nLeft+oCtrl:nWidth,oCtrl:nTop+oCtrl:nHeight )
   oCtrl:nLeft := nLeft

   IF oCtrl:oContainer <> Nil
      IF oContainer <> Nil .AND. oContainer:handle == oCtrl:oContainer:handle
         Return Nil
      ELSE
         i := Ascan( oCtrl:oContainer:aControls,{|o|o:handle==oCtrl:handle} )
         IF i <> 0
            Adel( oCtrl:oContainer:aControls,i )
            Asize( oCtrl:oContainer:aControls,Len(oCtrl:oContainer:aControls)-1 )
         ENDIF
         oCtrl:oContainer := Nil
         oCtrl:lEmbed := .F.
      ENDIF
   ENDIF

   IF oContainer <> Nil
      oContainer:AddControl( oCtrl )
      oCtrl:oContainer := oContainer
      IF Lower( oContainer:cClass ) == "page"
         oCtrl:nPage := GetCurrentTab( oContainer:handle )
         IF oCtrl:nPage == 0
            oCtrl:nPage ++
         ENDIF
      ENDIF

      IF ( i := Ascan( oDlg:aControls,{|o|o:handle==oCtrl:handle} ) )  < Ascan( oDlg:aControls,{|o|o:handle==oContainer:handle} )
         DestroyWindow( oCtrl:handle )
         aDel( oDlg:aControls,i )
         oDlg:aControls[Len(oDlg:aControls)] := oCtrl
         oCtrl:lInit := .F.
         oCtrl:Activate()
      ENDIF
   ENDIF

Return Nil

Static Function CtrlByRect( oDlg,xPos1,yPos1,xPos2,yPos2 )
Local i := 1, j := 0, aControls := oDlg:aControls, alen := Len( aControls )
Local oCtrl

   while i <= alen



     IF !aControls[i]:lHide .AND. xPos1 >= aControls[i]:nLeft .AND.  xPos2 <= ( aControls[i]:nLeft+aControls[i]:nWidth ) .AND.  yPos1 >= aControls[i]:nTop .AND.                          yPos2 <= ( aControls[i]:nTop+aControls[i]:nHeight )
        oCtrl := aControls[i]
        IF j == 0
           j := i
        ENDIF
        aControls := oCtrl:aControls
        i := 0
        alen := Len( aControls )
     ENDIF
     i ++
   ENDDO
   IF oCtrl <> Nil
      aControls := oDlg:aControls
      alen := Len( aControls )
      i := j + 1
      while i <= alen




         IF !aControls[i]:lHide .AND. xPos1 >= aControls[i]:nLeft .AND.  xPos2 <= ( aControls[i]:nLeft+aControls[i]:nWidth ) .AND.  yPos1 >= aControls[i]:nTop .AND.                          yPos2 <= ( aControls[i]:nTop+aControls[i]:nHeight ) .AND.  aControls[i]:nLeft > oCtrl:nLeft .AND. aControls[i]:nTop > oCtrl:nTop
            oCtrl := aControls[i]
            EXIT
         ENDIF
         i ++
      ENDDO
   ENDIF
Return oCtrl

Static Function CtrlByPos( oDlg,xPos,yPos )
Local i := 1, j := 0, aControls := oDlg:aControls, alen := Len( aControls )
Local oCtrl


   while i <= alen




     IF !aControls[i]:lHide .AND. xPos >= aControls[i]:nLeft .AND.  xPos < ( aControls[i]:nLeft+aControls[i]:nWidth ) .AND.  yPos >= aControls[i]:nTop .AND.                          yPos < ( aControls[i]:nTop+aControls[i]:nHeight )
        oCtrl := aControls[i]

        IF j == 0
           j := i
        ENDIF
        aControls := oCtrl:aControls
        i := 0
        alen := Len( aControls )
     ENDIF
     i ++
   ENDDO
   IF oCtrl <> Nil
      aControls := oDlg:aControls
      alen := Len( aControls )
      i := j + 1
      while i <= alen




         IF !aControls[i]:lHide .AND. xPos >= aControls[i]:nLeft .AND.  xPos < ( aControls[i]:nLeft+aControls[i]:nWidth ) .AND.  yPos >= aControls[i]:nTop .AND.                          yPos < ( aControls[i]:nTop+aControls[i]:nHeight ) .AND.  aControls[i]:nLeft > oCtrl:nLeft .AND. aControls[i]:nTop > oCtrl:nTop
            oCtrl := aControls[i]
            EXIT
         ENDIF
         i ++
      ENDDO
   ENDIF
Return oCtrl

Static Function FrmSort( oForm,aControls,lSub )
Local i, nLeft, nTop, lSorted := .T., aTabs

   FOR i := 1 TO Len( aControls )
      IF i > 1 .AND. aControls[i]:nTop*10000+aControls[i]:nLeft < nTop*10000+nLeft
         lSorted := .F.
         EXIT
      ENDIF
      nLeft := aControls[i]:nLeft
      nTop  := aControls[i]:nTop
   NEXT

   IF !lSorted .AND. ( lSub == Nil .OR. !lSub )
      FOR i := Len( aControls ) TO 1 STEP -1
         DestroyWindow( aControls[i]:handle )
      NEXT
   ENDIF
   IF !lSorted





      Asort( aControls,,, {|z,y| z:nTop*10000+z:nLeft < y:nTop*10000+y:nLeft } )

   ENDIF
   FOR i := 1 TO Len( aControls )
      IF !Empty( aControls[i]:aControls )
         FrmSort( oForm,aControls[i]:aControls,.T. )
      ENDIF
   NEXT
   IF !lSorted .AND. ( lSub == Nil .OR. !lSub )
      FOR i := 1 TO Len( aControls )
         aControls[i]:lInit := .F.
         aControls[i]:Activate()
         aControls[i]:lHide := .F.
      NEXT
      FOR i := 1 TO Len( aControls )


         IF Lower( aControls[i]:cClass ) == "page" .AND.  ( aTabs := aControls[i]:GetProp("Tabs") ) <> Nil .AND.  !Empty( aTabs )
            Page_Upd( aControls[i], aTabs )
            Page_Select( aControls[i], 1, .T. )
         ENDIF
      NEXT
   ENDIF
Return Nil

Function DoPreview()
Local oForm
Local cTemp1, cTemp2, lc := .F.
Local oTmpl
Memvar oDesigner

   IF HFormGen():oDlgSelected == Nil
      MsgStop( "No Form in use!", "Designer" )
      Return Nil
   ENDIF

   oForm := HFormGen():oDlgSelected:oParent
   IF oForm:lChanged .OR. oForm:type > 1 .OR. oForm:path = Nil
      lc := .T.
      cTemp1 := oForm:filename; cTemp2 := oForm:path
      oForm:filename := "__tmp.xml"
      oForm:path     := ""
      oForm:type     := 1
      oForm:lChanged := .T.
      oForm:Save()
   ENDIF


   oTmpl := Iif( oDesigner:lReport, HRepTmpl():Read( oForm:path+oForm:filename ),  HFormTmpl():Read( oForm:path+oForm:filename ) )

   IF lc
      oForm:filename := cTemp1
      oForm:path     := cTemp2
      oForm:lChanged := .T.
   ENDIF

   IF oDesigner:lReport
      oTmpl:Print( ,.T. )
   ELSE
      oTmpl:Show()
   ENDIF
   oTmpl:Close()

Return Nil

Function _CHR( n )
Return CHR( n )
